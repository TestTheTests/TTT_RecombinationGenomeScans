# Hapflk Analysis

This folder contains the scripts used to perform a hapflk analysis on a collection of VCFs

## K selection

K (number of clusters) selection was done by using the imputeqc package provided by Gennady Khvorykh [here](https://github.com/inzilico/imputeqc).
The process was computationally expensive, so I tested 3 values (K=5, K=10, K=15) on a small subset of the data (chromosome 1 of simulation 10900).
This imputeqc package follows the cross-validation procedure assumed in fastPHASE, where a proportion of the genotypes in the file are masked and
fastPHASE is made to predict the missing genotypes using the number of clusters being tested. I used the imputeqc defaults in the masking process,
which were to create 5 different masked datasets with 10% of the genotypes masked in each one. I then used the package to calculate the fastPHASE
error rate for each mask and find the mean error rate for each value of K. 

K=10 had a 0.0485552 mean error rate  
K=15 had a 0.0390178 mean error rate  
K=20 had a 0.0328386 mean error rate  

I selected K=15 to use in the analysis to keep computational costs down   

## run_hapflk.sh

This script is designed so that it can be easily run on a remote linux server (longest part of analysis). It depends on the scripts in the src folder
in this repository. The process:

	1) Calculate kinship matrix for full dataset (all SNPs, unpruned)

	2) Calculate kinship matrix for pruned dataset

	3) Split data set into 10 separate files, one for each chromosome

	4) Run hapflk on each chromosome individually using 3 combinations of kinship matrices and data:
		- full dataset matrix, full dataset
		- pruned dataset matrix, pruned dataset
		- pruned dataset matrix, full dataset

	5) Combine results from all chromosomes into one table

To execute this workflow, simply run the script in a folder containing the required input files. For each simulation, you need a VCF file (zipped or 
unzipped), a "ScanResults" file that indicates which alleles are quasi-independent, and a "indFILT" file that provides information about the individuals
in the sample and how they are grouped.

## Calculating p-values

The hapflk [documenation](https://forge-dga.jouy.inra.fr/documents/588) includes a python script (scaling_chi2_hapflk.py) for calculating p-values
from hapflk results. It depends on several python packages, some of which were not installed in my remote environment, so I kept this part of the 
analysis separate from run_hapflk.sh. A simple bash for loop, which can be found in get_p_values.sh, was used to apply scaling_chi2_hapflk.py to 
each table created in step 5 of the hapflk analysis above.

## combine hapflk_tables.R

combine_hapflk_tables.R is an Rscript provided in "src" to combine the scaled results from each of the 3 combinations of kinship matrices and data into one table that makes the results easy to compare. It can take command line arguments or will just run on defaults if there are none provided. These are the 5 arguments it can take, unnamed and in this order:
	
	1) start       -- the first sim in the set
	2) end         -- the last sim in the set
	3) directory   -- where are the results tables located
	4) type of sim -- points the script to the names of the tables (ex "Invers")
	5) directory   -- where are the indexes of the quasi-indep alleles located

The final parameter allows the script to combine pruned and unpruned datsets, it points the script to where it can find a collection of files
generated by pruneSNPs.pl that tell the script which SNPs were kept after pruning.

The final results are reported as tables called "xxxxx_Invers_hapflk_scores_sc.txt", where xxxxx is the sim number. These tables contain scores for each SNP from each analysis (pruned, unpruned, pruned kinship)

## Description of Output

There are 3 different runs in the analysis:
1) Hapflk run on all the SNPs using a kinship matrix calculated from all the SNPs
2) Hapflk run on only quasi-independent SNPs using a kinship matrix calculated from only the quasi-independent SNPs
3) Hapflk run on all SNPs using a kinship matrix calculated from only the quasi-independent SNPs

And 3 different versions of the hapflk statistic reported for each run:
1) Raw hapflk value
2) Scaled hapflk value, calculated using the python script mentioned above
3) -log10(p-value). The p value is also taken from the output of the python script output

The table below gives a description of each column in the output files.

**Why is the hapflk score different (sometimes significantly so) in run 2 and run 3 for the same quasi-independent SNPs using the same matrix?** 
The hapflk statistic is an extension of the FLK statistic ([Bonhomme et al. 2010](http://www.genetics.org/content/186/1/241?ijkey=256eadbfed5d4d2b46869d5bb4c3442ca7b81202&keytype2=tf_ipsecsha)) . Like the FLK statistic, it incorporates hierarchical population structure (the kinship matrix), but it extends this model by also taking into account the haplotype structure of the sample. It divides the input chromosomes into clusters, and when the non-independent loci are excluded these clusters are different and the hapflk statistic that is calculated is different. The FLK statistic, which is not reported here but can be found by looking at the output of run_hapflk.sh, is the same for these SNPs in both runs 2 and 3.    

| Column Name                       | Description
| :-------------------------------  | :------------------------------------------
| rs                                | index used to combine results from different runs. Identifies which SNP is which
| chr                               | chromosome (linkage group)
| pos	                            | position of the SNP in bp
| hapflk_v1.4.ALL                   | 'raw' hapflk value from the run using all SNPs and a matrix derived from all SNPs
| hapflk_v1.4.ALL                   | hapflk value from the same run (all SNPs, matrix uses all SNPs), scaled using the python script
| hapflk_v1.4.ALL_log_pvalue        | log10 p-value from the same run (all SNPs, matrix uses all SNPs). The p-value comes from the python script output, log10 is taken of it before it is added to the table
| hapflk_v1.4_PRUNED                | 'raw' hapflk value from the run using only quasi-independent SNPs in both the kinship matrix and the analysis
| hapflk_v1.4_PRUNED_scaled         | scaled hapflk value from the run using only quasi-independent SNPs in both the kinship matrix and the analysis
| hapflk_v1.4_PRUNED_log_pvalue     | log10 p-value from the run using only quasi-independt SNPs in both the kinship matrix and the analysis
| hapflk_v1.4_PRUNED_KIN            | 'raw' hapflk value from the run using only quasi-independent SNPs in generating the kinship matrix but all SNPs in the analysis
| hapflk_v1.4_PRUNED_KIN_scaled     | scaled hapflk value from the run using only quasi-independent SNPs in generating the kinship matrix but all SNPs in the analysis
| hapflk_v1.4_PRUNED_KIN_log_pvalue | log10 p-value from the run using only quasi-independent SNPs in generating the kinship matrix but all SNPs in the analysis
